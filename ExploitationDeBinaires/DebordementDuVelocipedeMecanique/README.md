# Debordement du Vélocipède Mécanique

## Fichiers joints au challenge

- [vm](vm)
- [pwn_my_vm.vmr](pwn_my_vm.vmr)

## Docker à déployer

Cf [Dockerfile](Dockerfile)

Fichiers déployés
- [vm](vm)
- [pwn_my_vm.vmr](pwn_my_vm.vmr)
- [.passwd](.passwd)

## Résolution

### Analyse du bytecode

La VM est assez proche d'un processeur x86. On retrouve notamment le fonction call / ret, avec une adresse de retour poussée sur la stack.
La différence au niveau des call, c'est qu'au lieu de faire `call(int address)` on fait `call(char fnsize, char[fnsize] function_name)`.

Dans le bytecode qui nous est fourni, on a 3 fonctions :

- `main`
- `say_name`
- `read_flag`

La fonction `main` appelle directement la fonction `say_name`.

La fonction `say_name` :

- Affiche "What's your name?".
- Lis une entrée utilisateur de longueur 20
- Affiche l'entrée utilisateur suivie de "! That's a really nice name"
- ret

La fonction `read_flag` lis le contenu du fichier `.passwd` et l'affiche, mais elle n'est malheureusement pas appelée :(

## Analyse de la VM

On peut identifier dans le comportement-même de la VM que la fonction qui gère les entrées utilisateur a une faiblesse.

En effet, elle alloue dans la mémoire de la VM un espace de `size` caractères (ici 20 par exemple), mais va copier l'entièreté de la chaîne de caractère dont elle lit la longueur avec la fonction C `strlen`. Si on lui passe une entrée plus grande que la taille attendue, on aura donc affaire à un buffer overflow.

Dans la fonction `say_name` qui nous est donnée, on peut représenter la stack de la VM de la mannière suivante :

| sUserInput[20] | sAskName[19] | sNiceName[30]    | uRetAddr |
|----------------|--------------|------------------|----------|
| "Cyxo"         | "What's ..." | "! That's a ..." | 0x100a4  |

On peut voir la valeur de l'adresse de retour en débuggant le programme en local. C'est aussi 0x10000 + l'offset de l'instruction dans le bytecode (0xa4), donc on peut aussi le voir en ouvrant le bytecode avec un éditeur hexa.

Le début du contenu de la fonction `read_flag` se situe à l'offset 0x0e. On va donc essayer d'écraser l'adresse de retour pour remplacer le 0xa4 par 0x0e (les adresses sont en little endian donc le premier octet qu'on écrase est directement celui qu'on veut).

Il nous faut donc 20+19+30 = 69 caractères de bourrage + \x0e

On peut le vérifier en local avec cette commande simple :

```sh
python3 -c 'print("A"*69 + "\x0E")' | ./vm pwn_my_vm.vmr
```

Avec un fichier `.passwd` qui contient `404CTF{test}`, la commande nous donne la sortie suivante :

```
What's your name?
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA404CTF{test}
```

On a bien réussi à appeler la fonction `read_flag` (ou du moins son contenu) en modifiant l'adresse de retour !