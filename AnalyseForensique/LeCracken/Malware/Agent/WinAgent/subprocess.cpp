#include "subprocess.h"
#include <iostream>

Subprocess::Subprocess(string cmdline) {

	// Setup pipes
	SECURITY_ATTRIBUTES pipeSecurityAttributes;
	pipeSecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	pipeSecurityAttributes.bInheritHandle = TRUE;
	pipeSecurityAttributes.lpSecurityDescriptor = NULL;
	if (!CreatePipe(&this->stdinReadHandle, &this->stdinWriteHandle, &pipeSecurityAttributes, 0)) {
		exit(1);
	}
	if (!SetHandleInformation(this->stdinWriteHandle, HANDLE_FLAG_INHERIT, 0)) {
		exit(1);
	}
	if (!CreatePipe(&this->stdoutReadHandle, &this->stdoutWriteHandle, &pipeSecurityAttributes, 0)) {
		exit(1);
	}
	if (!SetHandleInformation(this->stdoutReadHandle, HANDLE_FLAG_INHERIT, 0)) {
		exit(1);
	}

	// Start the child process
	STARTUPINFO startupInfo;
	ZeroMemory(&startupInfo, sizeof(STARTUPINFO));
	startupInfo.cb = sizeof(STARTUPINFO);
	startupInfo.hStdError = this->stdoutWriteHandle;
	startupInfo.hStdOutput = this->stdoutWriteHandle;
	startupInfo.hStdInput = this->stdinReadHandle;
	startupInfo.dwFlags = STARTF_USESTDHANDLES;
	ZeroMemory(&this->processInfo, sizeof(PROCESS_INFORMATION));
	CreateProcess(
		NULL, // No application name, we are passing a command line
		const_cast<char*>(cmdline.c_str()),
		NULL,
		NULL,
		TRUE, // Inherit handles
		CREATE_NO_WINDOW,
		NULL, // Keep parent env
		NULL, // Stay in parent working directory
		&startupInfo,
		&this->processInfo
	);
}

size_t Subprocess::read(BYTE* buffer, size_t size) {
	DWORD available;
	if (!PeekNamedPipe(this->stdoutReadHandle, NULL, NULL, NULL, &available, NULL)) {
		exit(1);
	}
	size = available < size ? available : size;
	if (size <= 0) return 0;
	DWORD read;
	if (!ReadFile(this->stdoutReadHandle, buffer, size, &read, NULL)) {
		exit(1);
	}
	return read;
}

bool Subprocess::write(BYTE* buffer, size_t size) {
	size_t written;
	return !WriteFile(this->stdinWriteHandle, buffer, size, (LPDWORD)&written, NULL);
}

bool Subprocess::isAlive() {
	return WaitForSingleObject(this->processInfo.hProcess, 0) == WAIT_TIMEOUT;
}

int Subprocess::getProcessId() {
	return this->processInfo.dwProcessId;
}