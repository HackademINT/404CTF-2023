#include "crypto.h"
#include <ntstatus.h>

string KEY = "-----BEGIN PUBLIC KEY-----\r\n"
"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuZ8N/aBBtJTT0zUKnQ6J\r\n"
"aXu3Pp6UZe2CyzmnyUrqIu5uTECT1UAJ7VMBno2nLS6ZMSvwKDzrk2j1THq+PvRA\r\n"
"rD4ykq7hvGLkuTXrUAFzDiWu6rIC9qzCuH0dUFszFN1uYqYgmCCjo46qzFbjV2DN\r\n"
"XPYLMys4euuqFN7M56vgjAbVwr/xbRBxUNdLmwd1wR8rsJf4DcKrm45VkQKXx8lO\r\n"
"gCUs45+tRJUQWIvOnHtiJtDP4OaeJE1pQ99B/1Z1vz7onU9AbKG0d0+bW7OW+BgM\r\n"
"OdIBKYEU0U9FTU73ZFr0SmWR+a+ksqkBwm7l/zIwrKhhfiX1YGF2+3Vl7CvvtK6e\r\n"
"0wIDAQAB\r\n"
"-----END PUBLIC KEY-----";

void handleError(NTSTATUS status)
{
	switch (status)
	{
	case STATUS_SUCCESS: // success
		// no-op
		return;
	case STATUS_NOT_SUPPORTED:
	case STATUS_NOT_FOUND:
	case STATUS_NO_MEMORY:
	case STATUS_INVALID_PARAMETER:
	case STATUS_BUFFER_TOO_SMALL:
	case STATUS_INVALID_BUFFER_SIZE:
	case STATUS_INVALID_HANDLE:
	case STATUS_AUTH_TAG_MISMATCH:
	default:
		exit(1);
	}
}

CryptoSession::CryptoSession() {
	int status;
	status = BCryptOpenAlgorithmProvider(
		&this->aesHandle,
		BCRYPT_AES_ALGORITHM,
		NULL, 0
	);
	handleError(status);
	status = BCryptSetProperty(
		this->aesHandle,
		BCRYPT_CHAINING_MODE,
		(PBYTE)BCRYPT_CHAIN_MODE_CBC,
		sizeof(BCRYPT_CHAIN_MODE_CBC),
		0
	);
	handleError(status);
	BYTE random[SESSION_KEY_SIZE];
	status = BCryptGenRandom(
		BCRYPT_RNG_ALG_HANDLE,
		random, SESSION_KEY_SIZE,
		0
	);
	handleError(status);
	status = BCryptGenerateSymmetricKey(
		this->aesHandle,
		&this->sessionKeyHandle,
		NULL, 0,
		random, SESSION_KEY_SIZE,
		0
	);
	handleError(status);
	ULONG exportedBlobSize;
	status = BCryptExportKey(
		this->sessionKeyHandle,
		NULL,
		BCRYPT_KEY_DATA_BLOB,
		NULL, 0,
		&exportedBlobSize,
		0
	);
	handleError(status);
	BYTE* exportedKey = (BYTE*)LocalAlloc(0, exportedBlobSize);
	BCRYPT_KEY_DATA_BLOB_HEADER* exportedHeader = (BCRYPT_KEY_DATA_BLOB_HEADER*)exportedKey;
	status = BCryptExportKey(
		this->sessionKeyHandle,
		NULL,
		BCRYPT_KEY_DATA_BLOB,
		exportedKey, exportedBlobSize,
		&exportedBlobSize,
		0
	);
	CopyMemory(
		this->sessionKey,
		exportedKey + sizeof(BCRYPT_KEY_DATA_BLOB_HEADER),
		exportedHeader->cbKeyData
	);
	LocalFree(exportedKey);
}

CryptoSession::~CryptoSession() {
	if (!BCryptDestroyKey(
		this->sessionKeyHandle
	)) exit(1);
	if (!BCryptCloseAlgorithmProvider(
		this->aesHandle, 0
	)) exit(1);
}

vector<BYTE> CryptoSession::getProtectedSessionKey() {
	BCRYPT_KEY_HANDLE keyHandle;
	BCRYPT_ALG_HANDLE algorithm;
	if (BCryptOpenAlgorithmProvider(&algorithm, BCRYPT_RSA_ALGORITHM, NULL, 0) != 0) {
		exit(1);
	}

	BYTE* decodedKey = NULL;
	DWORD decodedKeySize = 0;
	if (!CryptStringToBinaryA(
		KEY.c_str(), 0, CRYPT_STRING_BASE64_ANY,
		NULL, &decodedKeySize,
		0, 0
	)) exit(1);
	decodedKey = (BYTE*)LocalAlloc(0, decodedKeySize);
	if (!CryptStringToBinaryA(
		KEY.c_str(), KEY.size(), CRYPT_STRING_BASE64HEADER,
		decodedKey, &decodedKeySize,
		0, NULL
	)) exit(1);

	PCERT_PUBLIC_KEY_INFO publicKeyInfo;
	if (!CryptDecodeObjectEx(
		X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		X509_PUBLIC_KEY_INFO, decodedKey, decodedKeySize,
		CRYPT_DECODE_ALLOC_FLAG |
		CRYPT_DECODE_NOCOPY_FLAG |
		CRYPT_DECODE_SHARE_OID_STRING_FLAG, 0,
		&publicKeyInfo, &decodedKeySize
	)) exit(1);
	LocalFree(decodedKey);
	BCRYPT_RSAKEY_BLOB* publicKeyBlob;
	if (!CryptDecodeObjectEx(
		X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		CNG_RSA_PUBLIC_KEY_BLOB,
		publicKeyInfo->PublicKey.pbData,
		publicKeyInfo->PublicKey.cbData,
		CRYPT_DECODE_ALLOC_FLAG, 0,
		&publicKeyBlob, &decodedKeySize
	)) exit(1);

	if (BCryptImportKeyPair(
		algorithm,
		NULL,
		BCRYPT_RSAPUBLIC_BLOB,
		&keyHandle,
		(PUCHAR)publicKeyBlob, decodedKeySize,
		0) != 0
		) exit(1);
	LocalFree(publicKeyInfo);

	BYTE encrypted[256];
	ULONG outSize;
	BCryptEncrypt(
		keyHandle,
		this->sessionKey, SESSION_KEY_SIZE,
		NULL,
		NULL, 0,
		encrypted, 256, &outSize,
		BCRYPT_PAD_PKCS1
	);

	if (BCryptCloseAlgorithmProvider(algorithm, 0) != 0) {
		exit(1);
	}

	return vector<BYTE>(encrypted, encrypted + outSize);
}

vector<BYTE> CryptoSession::encrypt(vector<BYTE> data) {
	data.insert(data.begin(), (BYTE)data.size());
	BYTE iv[16];
	CopyMemory(iv, this->iv, sizeof(this->iv));
	int status;
	ULONG encryptedSize;
	status = BCryptEncrypt(
		this->sessionKeyHandle,
		&data[0], data.size(), // Input
		NULL,		// Padding
		iv, sizeof(iv),	// IV
		NULL, NULL, // Output
		&encryptedSize,
		BCRYPT_BLOCK_PADDING
	);
	handleError(status);
	BYTE* encrypted = (BYTE*) LocalAlloc(0, encryptedSize);
	status = BCryptEncrypt(
		this->sessionKeyHandle,
		&data[0], data.size(), // Input
		NULL,		// Padding
		iv, sizeof(iv),	// IV
		encrypted, encryptedSize, // Output
		&encryptedSize,
		BCRYPT_BLOCK_PADDING
	);
	handleError(status);
	vector<BYTE> out = vector<BYTE>(encrypted, encrypted + encryptedSize);
	LocalFree(encrypted);
	return out;
}

vector<BYTE> CryptoSession::decrypt(vector<BYTE> data) {
	BYTE iv[16];
	CopyMemory(iv, this->iv, sizeof(this->iv));
	int status;
	ULONG decryptedSize;
	status = BCryptDecrypt(
		this->sessionKeyHandle,
		&data[0], data.size(), // Input
		NULL,		// Padding
		iv, sizeof(iv),	// IV
		NULL, NULL, // Output
		&decryptedSize,
		0
	);
	handleError(status);
	BYTE* decrypted = (BYTE*)LocalAlloc(0, decryptedSize);
	status = BCryptDecrypt(
		this->sessionKeyHandle,
		&data[0], data.size(), // Input
		NULL,		// Padding
		iv, sizeof(iv),	// IV
		decrypted, decryptedSize, // Output
		&decryptedSize,
		0
	);
	handleError(status);
	decryptedSize = decrypted[0];
	vector<BYTE> out = vector<BYTE>(decrypted + 1, decrypted + decryptedSize + 1);
	LocalFree(decrypted);
	return out;
}